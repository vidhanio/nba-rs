use std::{
    collections::{HashMap, HashSet},
    env, fs,
    path::Path,
};

use anyhow::Result;
use heck::ToPascalCase;
use quote::quote;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
struct AnalyzedEndpoint {
    endpoint: String,
    last_validated_date: String,
    status: Status,
    data_sets: HashMap<String, HashSet<String>>,
    parameters: HashSet<String>,
    required_parameters: HashSet<String>,
    nullable_parameters: HashSet<String>,
    parameter_patterns: HashMap<String, Option<String>>,
}

#[derive(Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
enum Status {
    Success,
    Invalid,
    Deprecated,
}

fn main() -> Result<()> {
    let out_dir = env::var("OUT_DIR")?;
    let dest_path = Path::new(&out_dir).join("analysis.rs");

    let analysis = fs::read_to_string("src/stats/analysis.json")?;
    let endpoints = serde_json::from_str::<Vec<AnalyzedEndpoint>>(&analysis)?;

    let ep = endpoints
        .into_iter()
        .map(
            |AnalyzedEndpoint {
                 endpoint,
                 last_validated_date,
                 status,
                 data_sets,
                 parameters,
                 required_parameters,
                 nullable_parameters,
                 parameter_patterns,
             }| {
                let endpoint_type = endpoint.to_pascal_case();

                quote! {
                    mod #endpoint {
                        struct #endpoint_type
                    }
                }
            },
        )
        .collect::<Vec<_>>();

    println!("cargo:rerun-if-changed=src/stats/analysis.json");

    Ok(())
}
